import React, { createElement, createContext, useContext, useState, useCallback, useRef, useMemo, useEffect } from 'react';
import Reveal from 'reveal.js';
import 'reveal.js/dist/reveal.css';
import HighlightPlugin$1 from 'reveal.js/plugin/highlight/highlight.esm';
import MathPlugin$1 from 'reveal.js/plugin/math/math.esm';
import MarkdownPlugin$1 from 'reveal.js/plugin/markdown/markdown.esm';
import NotesPlugin$1 from 'reveal.js/plugin/notes/notes.esm';
import SearchPlugin$1 from 'reveal.js/plugin/search/search.esm';
import ZoomPlugin$1 from 'reveal.js/plugin/zoom/zoom.esm';
import Prism from 'prismjs';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-tsx';
import 'prismjs/components/prism-typescript';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function getClassNameProps(baseProps) {
  var className = baseProps.className,
      fragment = baseProps.fragment,
      fragmentStyle = baseProps.fragmentStyle,
      fitText = baseProps.fitText,
      props = _objectWithoutProperties(baseProps, ["className", "fragment", "fragmentStyle", "fitText"]);

  var classes = className ? [className] : [];
  if (fragment) classes.push('fragment');
  if (fitText) classes.push('r-fit-text');
  if (fragmentStyle) classes.push(fragmentStyle);
  if (!classes.length) return props;
  return _objectSpread2(_objectSpread2({}, props), {}, {
    className: classes.join(' ')
  });
}
function generateBaseComponent(component) {
  var Component = function Component(props) {
    return BaseComponent(_objectSpread2(_objectSpread2({}, props), {}, {
      component: component
    }));
  };

  Component.displayName = "".concat(component[0].toUpperCase()).concat(component.slice(1));
  return Component;
}
function BaseComponent(_ref) {
  var component = _ref.component,
      autoAnimateId = _ref.autoAnimateId,
      fragmentIndex = _ref.fragmentIndex,
      children = _ref.children,
      props = _objectWithoutProperties(_ref, ["component", "autoAnimateId", "fragmentIndex", "children"]);

  return /*#__PURE__*/createElement(component, _objectSpread2(_objectSpread2({}, getClassNameProps(props)), {}, {
    'data-id': autoAnimateId,
    'data-fragment-index': fragmentIndex,
    children: children
  }));
}

var componentsToGenerate = {
  h1: generateBaseComponent('h1'),
  h2: generateBaseComponent('h2'),
  h3: generateBaseComponent('h3'),
  h4: generateBaseComponent('h4'),
  h5: generateBaseComponent('h5'),
  h6: generateBaseComponent('h6'),
  blockquote: generateBaseComponent('blockquote'),
  div: generateBaseComponent('div'),
  figcaption: generateBaseComponent('figcaption'),
  figure: generateBaseComponent('figure'),
  footer: generateBaseComponent('footer'),
  header: generateBaseComponent('header'),
  li: generateBaseComponent('li'),
  main: generateBaseComponent('main'),
  ol: generateBaseComponent('ol'),
  p: generateBaseComponent('p'),
  span: generateBaseComponent('span'),
  ul: generateBaseComponent('ul')
};
var H1 = componentsToGenerate.h1;
var H2 = componentsToGenerate.h2;
var H3 = componentsToGenerate.h3;
var H4 = componentsToGenerate.h4;
var H5 = componentsToGenerate.h5;
var H6 = componentsToGenerate.h6;
var BlockQuote = componentsToGenerate.blockquote;
var Div = componentsToGenerate.div;
var FigCaption = componentsToGenerate.figcaption;
var Figure = componentsToGenerate.figure;
var Footer = componentsToGenerate.footer;
var Header = componentsToGenerate.header;
var Li = componentsToGenerate.li;
var Main = componentsToGenerate.main;
var Ol = componentsToGenerate.ol;
var P = componentsToGenerate.p;
var Span = componentsToGenerate.span;
var Ul = componentsToGenerate.ul;

var defaultContextValue = {
  reveal: null,
  prism: false
};
var RevealContext = /*#__PURE__*/createContext(defaultContextValue);
function RevealProvider(_ref) {
  var reveal = _ref.reveal,
      children = _ref.children;
  // coerce the type to the actual reveal/plugin combo it is passed
  var Context = RevealContext;
  return /*#__PURE__*/React.createElement(Context.Provider, {
    value: reveal
  }, children);
}

function getPrismClassName(prism, autoAnimateId, lineNumbers, language) {
  if (!prism) {
    return undefined;
  }

  var lineNumberClassName = autoAnimateId || lineNumbers;
  return "".concat("language-".concat(language || 'none'), lineNumberClassName ? ' line-numbers' : '') || undefined;
}

function Code(_ref) {
  var id = _ref.id,
      children = _ref.children,
      language = _ref.language,
      escape = _ref.escape,
      fragmentIndex = _ref.fragmentIndex,
      lineNumbers = _ref.lineNumbers,
      startLineNumbersAt = _ref.startLineNumbersAt,
      noTrim = _ref.noTrim,
      autoAnimateId = _ref.autoAnimateId,
      props = _objectWithoutProperties(_ref, ["id", "children", "language", "escape", "fragmentIndex", "lineNumbers", "startLineNumbersAt", "noTrim", "autoAnimateId"]);

  var _useContext = useContext(RevealContext),
      prism = _useContext.prism;

  var prismClassName = getPrismClassName(prism, autoAnimateId, lineNumbers, language);
  var fancyProps = getClassNameProps(props);
  var calculatedClassName = fancyProps.className;
  var className = calculatedClassName && prismClassName ? "".concat(calculatedClassName, " ").concat(prismClassName) : prismClassName;
  return /*#__PURE__*/React.createElement("pre", _extends({}, fancyProps, {
    className: className,
    "data-id": autoAnimateId || id,
    id: id,
    "data-fragment-index": fragmentIndex,
    "data-line": typeof lineNumbers === 'string' ? lineNumbers : undefined,
    "data-line-offset": startLineNumbersAt
  }), /*#__PURE__*/React.createElement("code", {
    className: prism ? language ? "language-".concat(language) : 'language-none' : language,
    "data-noescape": !escape,
    "data-trim": !noTrim,
    "data-line-numbers": autoAnimateId ? lineNumbers || true : lineNumbers
  }, children.code));
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".example a {\n  font-size: 18px;\n}\n";
styleInject(css_248z);

function Example(_ref) {
  var _ref$source = _ref.source,
      code = _ref$source === void 0 ? '' : _ref$source,
      autoAnimateId = _ref.autoAnimateId,
      children = _ref.children;

  var _useState = useState('example'),
      _useState2 = _slicedToArray(_useState, 2),
      selected = _useState2[0],
      setSelected = _useState2[1];

  var show = useCallback(function (e, select) {
    e.preventDefault();
    setSelected(select);
  }, [setSelected]);
  return /*#__PURE__*/React.createElement("div", {
    className: "example"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: selected === 'example' ? 'block' : 'none'
    }
  }, children, /*#__PURE__*/React.createElement("a", {
    href: "#source",
    onClick: function onClick(e) {
      return show(e, 'source');
    }
  }, "show source")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: selected === 'source' ? 'block' : 'none'
    }
  }, /*#__PURE__*/React.createElement(Code, {
    lineNumbers: true,
    language: "tsx",
    autoAnimateId: autoAnimateId
  }, {
    code: code
  }), /*#__PURE__*/React.createElement("a", {
    href: "#example",
    onClick: function onClick(e) {
      return show(e, 'example');
    }
  }, "show example")));
}

var formatMap = {
  '3gp': 'audio/3gp',
  aac: 'audio/aac',
  flac: 'audio/flac',
  mpg: 'audio/mpeg',
  mpeg: 'audio/mpeg',
  mp3: 'audio/mp3',
  mp4: 'audio/mp4',
  m4a: 'audio/mp4',
  oga: 'audio/ogg',
  ogg: 'audio/ogg',
  wav: 'audio/wav',
  webm: 'audio/webm'
};

function Audio(_ref) {
  var autoplay = _ref.autoplay,
      className = _ref.className,
      controls = _ref.controls,
      fragment = _ref.fragment,
      fragmentIndex = _ref.fragmentIndex,
      fragmentStyle = _ref.fragmentStyle,
      lazy = _ref.lazy,
      loop = _ref.loop,
      muted = _ref.muted,
      preload = _ref.preload,
      src = _ref.src,
      props = _objectWithoutProperties(_ref, ["autoplay", "className", "controls", "fragment", "fragmentIndex", "fragmentStyle", "lazy", "loop", "muted", "preload", "src"]);

  if (Array.isArray(src)) {
    return /*#__PURE__*/React.createElement("audio", _extends({}, getClassNameProps(props), {
      "data-autoplay": autoplay,
      controls: controls,
      muted: muted,
      loop: loop,
      "data-fragment-index": fragmentIndex
    }), src.map(function (element) {
      var _$exec;

      return /*#__PURE__*/React.createElement("source", {
        src: lazy ? false : element,
        "data-src": lazy ? element : false,
        "data-preload": preload,
        type: formatMap[(_$exec = /\.[^.]+$/.exec(element)) === null || _$exec === void 0 ? void 0 : _$exec[0]] || 'mp3'
      });
    }));
  }

  return /*#__PURE__*/React.createElement("audio", _extends({}, getClassNameProps(props), {
    "data-autoplay": autoplay,
    src: lazy ? '' : src,
    "data-src": lazy ? src : false,
    "data-preload": preload,
    controls: controls,
    muted: muted,
    loop: loop,
    "data-fragment-index": fragmentIndex
  }));
}

function Fragment(_ref) {
  var index = _ref.index,
      transition = _ref.transition,
      children = _ref.children,
      _ref$tag = _ref.tag,
      tag = _ref$tag === void 0 ? 'span' : _ref$tag;
  var classes = ['fragment'];

  if (transition) {
    classes.push(transition);
  }

  var Tag = tag;
  return /*#__PURE__*/React.createElement(Tag, {
    className: classes.join(' '),
    "data-fragment-index": index
  }, children);
}

function IFrame(_ref) {
  var autoAnimateId = _ref.autoAnimateId,
      fragmentIndex = _ref.fragmentIndex,
      height = _ref.height,
      lazy = _ref.lazy,
      preload = _ref.preload,
      src = _ref.src,
      width = _ref.width,
      props = _objectWithoutProperties(_ref, ["autoAnimateId", "fragmentIndex", "height", "lazy", "preload", "src", "width"]);

  return /*#__PURE__*/React.createElement("iframe", _extends({}, getClassNameProps(props), {
    "data-id": autoAnimateId,
    src: lazy ? undefined : src,
    "data-src": lazy ? src : undefined,
    "data-preload": preload,
    width: width,
    height: height,
    "data-fragment-index": fragmentIndex
  }));
}

function Image(_ref) {
  var autoAnimateId = _ref.autoAnimateId,
      alt = _ref.alt,
      fragmentIndex = _ref.fragmentIndex,
      height = _ref.height,
      src = _ref.src,
      width = _ref.width,
      props = _objectWithoutProperties(_ref, ["autoAnimateId", "alt", "fragmentIndex", "height", "src", "width"]);

  return /*#__PURE__*/React.createElement("img", _extends({}, getClassNameProps(props), {
    "data-id": autoAnimateId,
    src: src,
    alt: alt,
    width: width,
    height: height,
    "data-fragment-index": fragmentIndex
  }));
}

function useReveal() {
  return useContext(RevealContext);
}

function getLinkFromSlide(reveal, slide) {
  if (!reveal) {
    return '#';
  }

  var indices = reveal.getIndices(slide);
  return function (e) {
    e.preventDefault();
    e.stopPropagation();
    reveal.slide(indices.h, indices.v, indices.f);
  };
}

function getLink(reveal, href, slide) {
  if (href) {
    return href;
  }

  if (!slide) {
    return '#';
  }

  if (typeof slide === 'string') {
    // slide is an id
    var slideById = document.querySelector("#".concat(slide));

    if (slideById) {
      return getLinkFromSlide(reveal, slideById);
    }
  } else if (typeof slide === 'number') {
    return "#".concat(slide - 1);
  } else if (Array.isArray(slide)) {
    return "#".concat(slide[0] - 1, "/").concat(slide[1] - 1);
  } else if (slide) {
    return getLinkFromSlide(reveal, slide);
  }

  return '#';
}

function Link(_ref) {
  var autoAnimateId = _ref.autoAnimateId,
      children = _ref.children,
      fragmentIndex = _ref.fragmentIndex,
      href = _ref.href,
      slide = _ref.slide,
      props = _objectWithoutProperties(_ref, ["autoAnimateId", "children", "fragmentIndex", "href", "slide"]);

  var _useReveal = useReveal(),
      reveal = _useReveal.reveal;

  var onClickOrHref = getLink(reveal, href, slide);
  var onClick = typeof onClickOrHref === 'function' ? onClickOrHref : undefined;
  var link = typeof onClickOrHref === 'string' ? onClickOrHref : undefined;
  return /*#__PURE__*/React.createElement("a", _extends({}, getClassNameProps(props), {
    "data-id": autoAnimateId,
    href: link,
    onClick: onClick,
    "data-fragment-index": fragmentIndex
  }), children);
}

function Note(props) {
  return /*#__PURE__*/React.createElement("aside", _extends({}, props, {
    className: "notes"
  }));
}

var defaultAutoAnimateStyles = ['opacity', 'color', 'background-color', 'padding', 'font-size', 'line-height', 'letter-spacing', 'border-width', 'border-color', 'border-radius', 'outline', 'outline-offset'];
var noPlugins = [];
function RevealJS(_ref) {
  var children = _ref.children,
      _ref$plugins = _ref.plugins,
      plugins = _ref$plugins === void 0 ? noPlugins : _ref$plugins,
      _ref$controls = _ref.controls,
      controls = _ref$controls === void 0 ? true : _ref$controls,
      _ref$controlsTutorial = _ref.controlsTutorial,
      controlsTutorial = _ref$controlsTutorial === void 0 ? true : _ref$controlsTutorial,
      _ref$controlsLayout = _ref.controlsLayout,
      controlsLayout = _ref$controlsLayout === void 0 ? 'bottom-right' : _ref$controlsLayout,
      _ref$controlsBackArro = _ref.controlsBackArrows,
      controlsBackArrows = _ref$controlsBackArro === void 0 ? 'faded' : _ref$controlsBackArro,
      _ref$progress = _ref.progress,
      progress = _ref$progress === void 0 ? true : _ref$progress,
      _ref$slideNumber = _ref.slideNumber,
      slideNumber = _ref$slideNumber === void 0 ? false : _ref$slideNumber,
      _ref$showSlideNumber = _ref.showSlideNumber,
      showSlideNumber = _ref$showSlideNumber === void 0 ? 'all' : _ref$showSlideNumber,
      _ref$hashOneBasedInde = _ref.hashOneBasedIndex,
      hashOneBasedIndex = _ref$hashOneBasedInde === void 0 ? false : _ref$hashOneBasedInde,
      _ref$hash = _ref.hash,
      hash = _ref$hash === void 0 ? false : _ref$hash,
      _ref$respondToHashCha = _ref.respondToHashChanges,
      respondToHashChanges = _ref$respondToHashCha === void 0 ? true : _ref$respondToHashCha,
      _ref$history = _ref.history,
      history = _ref$history === void 0 ? false : _ref$history,
      _ref$keyboard = _ref.keyboard,
      keyboard = _ref$keyboard === void 0 ? true : _ref$keyboard,
      _ref$keyboardConditio = _ref.keyboardCondition,
      keyboardCondition = _ref$keyboardConditio === void 0 ? null : _ref$keyboardConditio,
      _ref$disableLayout = _ref.disableLayout,
      disableLayout = _ref$disableLayout === void 0 ? false : _ref$disableLayout,
      _ref$overview = _ref.overview,
      overview = _ref$overview === void 0 ? true : _ref$overview,
      _ref$center = _ref.center,
      center = _ref$center === void 0 ? true : _ref$center,
      _ref$touch = _ref.touch,
      touch = _ref$touch === void 0 ? true : _ref$touch,
      _ref$loop = _ref.loop,
      loop = _ref$loop === void 0 ? false : _ref$loop,
      _ref$rtl = _ref.rtl,
      rtl = _ref$rtl === void 0 ? false : _ref$rtl,
      _ref$navigationMode = _ref.navigationMode,
      navigationMode = _ref$navigationMode === void 0 ? 'default' : _ref$navigationMode,
      _ref$shuffle = _ref.shuffle,
      shuffle = _ref$shuffle === void 0 ? false : _ref$shuffle,
      _ref$fragments = _ref.fragments,
      fragments = _ref$fragments === void 0 ? true : _ref$fragments,
      _ref$fragmentInURL = _ref.fragmentInURL,
      fragmentInURL = _ref$fragmentInURL === void 0 ? true : _ref$fragmentInURL,
      _ref$embedded = _ref.embedded,
      embedded = _ref$embedded === void 0 ? false : _ref$embedded,
      _ref$help = _ref.help,
      help = _ref$help === void 0 ? true : _ref$help,
      _ref$pause = _ref.pause,
      pause = _ref$pause === void 0 ? true : _ref$pause,
      _ref$showNotes = _ref.showNotes,
      showNotes = _ref$showNotes === void 0 ? false : _ref$showNotes,
      _ref$autoPlayMedia = _ref.autoPlayMedia,
      autoPlayMedia = _ref$autoPlayMedia === void 0 ? null : _ref$autoPlayMedia,
      _ref$preloadIframes = _ref.preloadIframes,
      preloadIframes = _ref$preloadIframes === void 0 ? null : _ref$preloadIframes,
      _ref$autoAnimate = _ref.autoAnimate,
      autoAnimate = _ref$autoAnimate === void 0 ? true : _ref$autoAnimate,
      _ref$autoAnimateMatch = _ref.autoAnimateMatcher,
      autoAnimateMatcher = _ref$autoAnimateMatch === void 0 ? null : _ref$autoAnimateMatch,
      _ref$autoAnimateEasin = _ref.autoAnimateEasing,
      autoAnimateEasing = _ref$autoAnimateEasin === void 0 ? 'ease' : _ref$autoAnimateEasin,
      _ref$autoAnimateDurat = _ref.autoAnimateDuration,
      autoAnimateDuration = _ref$autoAnimateDurat === void 0 ? 1.0 : _ref$autoAnimateDurat,
      _ref$autoAnimateUnmat = _ref.autoAnimateUnmatched,
      autoAnimateUnmatched = _ref$autoAnimateUnmat === void 0 ? true : _ref$autoAnimateUnmat,
      _ref$autoAnimateStyle = _ref.autoAnimateStyles,
      autoAnimateStyles = _ref$autoAnimateStyle === void 0 ? defaultAutoAnimateStyles : _ref$autoAnimateStyle,
      _ref$autoSlide = _ref.autoSlide,
      autoSlide = _ref$autoSlide === void 0 ? 0 : _ref$autoSlide,
      _ref$autoSlideStoppab = _ref.autoSlideStoppable,
      autoSlideStoppable = _ref$autoSlideStoppab === void 0 ? true : _ref$autoSlideStoppab,
      _ref$autoSlideMethod = _ref.autoSlideMethod,
      autoSlideMethod = _ref$autoSlideMethod === void 0 ? null : _ref$autoSlideMethod,
      _ref$defaultTiming = _ref.defaultTiming,
      defaultTiming = _ref$defaultTiming === void 0 ? null : _ref$defaultTiming,
      _ref$totalTime = _ref.totalTime,
      totalTime = _ref$totalTime === void 0 ? undefined : _ref$totalTime,
      _ref$mouseWheel = _ref.mouseWheel,
      mouseWheel = _ref$mouseWheel === void 0 ? false : _ref$mouseWheel,
      _ref$previewLinks = _ref.previewLinks,
      previewLinks = _ref$previewLinks === void 0 ? false : _ref$previewLinks,
      _ref$postMessage = _ref.postMessage,
      postMessage = _ref$postMessage === void 0 ? true : _ref$postMessage,
      _ref$postMessageEvent = _ref.postMessageEvents,
      postMessageEvents = _ref$postMessageEvent === void 0 ? false : _ref$postMessageEvent,
      _ref$focusBodyOnPageV = _ref.focusBodyOnPageVisibilityChange,
      focusBodyOnPageVisibilityChange = _ref$focusBodyOnPageV === void 0 ? true : _ref$focusBodyOnPageV,
      _ref$transition = _ref.transition,
      transition = _ref$transition === void 0 ? 'slide' : _ref$transition,
      _ref$transitionSpeed = _ref.transitionSpeed,
      transitionSpeed = _ref$transitionSpeed === void 0 ? 'default' : _ref$transitionSpeed,
      _ref$backgroundTransi = _ref.backgroundTransition,
      backgroundTransition = _ref$backgroundTransi === void 0 ? 'fade' : _ref$backgroundTransi,
      _ref$pdfMaxPagesPerSl = _ref.pdfMaxPagesPerSlide,
      pdfMaxPagesPerSlide = _ref$pdfMaxPagesPerSl === void 0 ? Number.POSITIVE_INFINITY : _ref$pdfMaxPagesPerSl,
      _ref$pdfSeparateFragm = _ref.pdfSeparateFragments,
      pdfSeparateFragments = _ref$pdfSeparateFragm === void 0 ? true : _ref$pdfSeparateFragm,
      _ref$pdfPageHeightOff = _ref.pdfPageHeightOffset,
      pdfPageHeightOffset = _ref$pdfPageHeightOff === void 0 ? -1 : _ref$pdfPageHeightOff,
      _ref$viewDistance = _ref.viewDistance,
      viewDistance = _ref$viewDistance === void 0 ? 3 : _ref$viewDistance,
      _ref$mobileViewDistan = _ref.mobileViewDistance,
      mobileViewDistance = _ref$mobileViewDistan === void 0 ? 2 : _ref$mobileViewDistan,
      _ref$display = _ref.display,
      display = _ref$display === void 0 ? 'block' : _ref$display,
      _ref$hideInactiveCurs = _ref.hideInactiveCursor,
      hideInactiveCursor = _ref$hideInactiveCurs === void 0 ? true : _ref$hideInactiveCurs,
      _ref$hideCursorTime = _ref.hideCursorTime,
      hideCursorTime = _ref$hideCursorTime === void 0 ? 5000 : _ref$hideCursorTime,
      _ref$parallaxBackgrou = _ref.parallaxBackgroundImage,
      parallaxBackgroundImage = _ref$parallaxBackgrou === void 0 ? '' : _ref$parallaxBackgrou,
      _ref$parallaxBackgrou2 = _ref.parallaxBackgroundSize,
      parallaxBackgroundSize = _ref$parallaxBackgrou2 === void 0 ? '' : _ref$parallaxBackgrou2,
      _ref$parallaxBackgrou3 = _ref.parallaxBackgroundRepeat,
      parallaxBackgroundRepeat = _ref$parallaxBackgrou3 === void 0 ? '' : _ref$parallaxBackgrou3,
      _ref$parallaxBackgrou4 = _ref.parallaxBackgroundPosition,
      parallaxBackgroundPosition = _ref$parallaxBackgrou4 === void 0 ? '' : _ref$parallaxBackgrou4,
      _ref$parallaxBackgrou5 = _ref.parallaxBackgroundHorizontal,
      parallaxBackgroundHorizontal = _ref$parallaxBackgrou5 === void 0 ? 200 : _ref$parallaxBackgrou5,
      _ref$parallaxBackgrou6 = _ref.parallaxBackgroundVertical,
      parallaxBackgroundVertical = _ref$parallaxBackgrou6 === void 0 ? 50 : _ref$parallaxBackgrou6,
      _ref$width = _ref.width,
      width = _ref$width === void 0 ? 960 : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === void 0 ? 700 : _ref$height,
      _ref$margin = _ref.margin,
      margin = _ref$margin === void 0 ? 0.04 : _ref$margin,
      _ref$minScale = _ref.minScale,
      minScale = _ref$minScale === void 0 ? 0.2 : _ref$minScale,
      _ref$maxScale = _ref.maxScale,
      maxScale = _ref$maxScale === void 0 ? 2.0 : _ref$maxScale,
      onDeckReady = _ref.onDeckReady,
      pluginProps = _ref.pluginProps;

  var _useState = useState(_objectSpread2(_objectSpread2({}, defaultContextValue), {}, {
    prism: !!(plugins !== null && plugins !== void 0 && plugins.find(function (plugin) {
      return plugin().id === 'prism-highlight';
    }))
  })),
      _useState2 = _slicedToArray(_useState, 2),
      revealContext = _useState2[0],
      setContextValue = _useState2[1];

  var revealRef = useRef(null);
  var revealDeck = useRef(null);
  var options = useMemo(function () {
    return _objectSpread2({
      plugins: plugins,
      controls: controls,
      controlsTutorial: controlsTutorial,
      controlsLayout: controlsLayout,
      controlsBackArrows: controlsBackArrows,
      progress: progress,
      slideNumber: slideNumber,
      showSlideNumber: showSlideNumber,
      hashOneBasedIndex: hashOneBasedIndex,
      hash: hash,
      respondToHashChanges: respondToHashChanges,
      history: history,
      keyboard: keyboard,
      keyboardCondition: keyboardCondition,
      disableLayout: disableLayout,
      overview: overview,
      center: center,
      touch: touch,
      loop: loop,
      rtl: rtl,
      navigationMode: navigationMode,
      shuffle: shuffle,
      fragments: fragments,
      fragmentInURL: fragmentInURL,
      embedded: embedded,
      help: help,
      pause: pause,
      showNotes: showNotes,
      autoPlayMedia: autoPlayMedia,
      preloadIframes: preloadIframes,
      autoAnimate: autoAnimate,
      autoAnimateMatcher: autoAnimateMatcher,
      autoAnimateEasing: autoAnimateEasing,
      autoAnimateDuration: autoAnimateDuration,
      autoAnimateUnmatched: autoAnimateUnmatched,
      autoAnimateStyles: autoAnimateStyles,
      autoSlide: autoSlide,
      autoSlideStoppable: autoSlideStoppable,
      autoSlideMethod: autoSlideMethod,
      defaultTiming: defaultTiming,
      totalTime: totalTime,
      mouseWheel: mouseWheel,
      previewLinks: previewLinks,
      postMessage: postMessage,
      postMessageEvents: postMessageEvents,
      focusBodyOnPageVisibilityChange: focusBodyOnPageVisibilityChange,
      transition: transition,
      transitionSpeed: transitionSpeed,
      backgroundTransition: backgroundTransition,
      pdfMaxPagesPerSlide: pdfMaxPagesPerSlide,
      pdfSeparateFragments: pdfSeparateFragments,
      pdfPageHeightOffset: pdfPageHeightOffset,
      viewDistance: viewDistance,
      mobileViewDistance: mobileViewDistance,
      display: display,
      hideInactiveCursor: hideInactiveCursor,
      hideCursorTime: hideCursorTime,
      parallaxBackgroundImage: parallaxBackgroundImage,
      parallaxBackgroundRepeat: parallaxBackgroundRepeat,
      parallaxBackgroundPosition: parallaxBackgroundPosition,
      parallaxBackgroundSize: parallaxBackgroundSize,
      parallaxBackgroundHorizontal: parallaxBackgroundHorizontal,
      parallaxBackgroundVertical: parallaxBackgroundVertical,
      width: width,
      height: height,
      margin: margin,
      minScale: minScale,
      maxScale: maxScale
    }, pluginProps);
  }, [plugins, controls, controlsTutorial, controlsLayout, controlsBackArrows, progress, slideNumber, showSlideNumber, hashOneBasedIndex, hash, respondToHashChanges, history, keyboard, keyboardCondition, disableLayout, overview, center, touch, loop, rtl, navigationMode, shuffle, fragments, fragmentInURL, embedded, help, pause, showNotes, autoPlayMedia, preloadIframes, autoAnimate, autoAnimateMatcher, autoAnimateEasing, autoAnimateDuration, autoAnimateUnmatched, autoAnimateStyles, autoSlide, autoSlideStoppable, autoSlideMethod, defaultTiming, totalTime, mouseWheel, previewLinks, postMessage, postMessageEvents, focusBodyOnPageVisibilityChange, transition, transitionSpeed, backgroundTransition, pdfMaxPagesPerSlide, pdfSeparateFragments, pdfPageHeightOffset, viewDistance, mobileViewDistance, display, hideInactiveCursor, hideCursorTime, parallaxBackgroundImage, parallaxBackgroundRepeat, parallaxBackgroundPosition, parallaxBackgroundSize, parallaxBackgroundHorizontal, parallaxBackgroundVertical, width, height, margin, minScale, maxScale, pluginProps]);
  useEffect(function () {
    if (!(revealRef !== null && revealRef !== void 0 && revealRef.current)) {
      return;
    }

    if (!revealDeck.current) {
      revealDeck.current = new Reveal(revealRef.current, options);
    }

    revealDeck.current.initialize(options).then(function () {
      if (revealDeck.current) {
        setContextValue({
          reveal: revealDeck.current,
          prism: !!revealDeck.current.getPlugin('prism-highlight')
        });
        onDeckReady === null || onDeckReady === void 0 ? void 0 : onDeckReady(revealDeck.current);
      }
    });
  }, [revealRef, options]);
  return /*#__PURE__*/React.createElement("div", {
    className: "reveal",
    ref: revealRef
  }, /*#__PURE__*/React.createElement("div", {
    className: "slides"
  }, /*#__PURE__*/React.createElement(RevealProvider, {
    reveal: revealContext
  }, children)));
}

function Slide(_ref) {
  var autoslide = _ref.autoslide,
      autoAnimate = _ref.autoAnimate,
      autoAnimateUnmatched = _ref.autoAnimateUnmatched,
      backgroundColor = _ref.backgroundColor,
      backgroundImage = _ref.backgroundImage,
      backgroundSize = _ref.backgroundSize,
      backgroundPosition = _ref.backgroundPosition,
      backgroundRepeat = _ref.backgroundRepeat,
      backgroundOpacity = _ref.backgroundOpacity,
      backgroundVideo = _ref.backgroundVideo,
      backgroundVideoLoop = _ref.backgroundVideoLoop,
      backgroundVideoMuted = _ref.backgroundVideoMuted,
      backgroundIframe = _ref.backgroundIframe,
      backgroundInteractive = _ref.backgroundInteractive,
      children = _ref.children,
      id = _ref.id,
      transition = _ref.transition,
      transitionSpeed = _ref.transitionSpeed,
      visibility = _ref.visibility,
      timing = _ref.timing;
  return /*#__PURE__*/React.createElement("section", {
    "data-autoslide": autoslide,
    id: id,
    "data-auto-animate": autoAnimate,
    "data-auto-animate-unmatched": autoAnimateUnmatched,
    "data-visibility": visibility,
    "data-background-color": backgroundColor,
    "data-background-image": backgroundImage,
    "data-background-size": backgroundSize,
    "data-background-position": backgroundPosition,
    "data-background-repeat": backgroundRepeat,
    "data-background-opacity": backgroundOpacity,
    "data-background-video": backgroundVideo,
    "data-background-video-loop": backgroundVideoLoop,
    "data-background-video-muted": backgroundVideoMuted,
    "data-background-iframe": backgroundIframe,
    "data-background-interactive": backgroundInteractive,
    "data-transition": transition,
    "data-transition-speed": transitionSpeed,
    "data-timing": timing
  }, children);
}

var formatMap$1 = {
  '3gp': 'video/3gpp',
  mpg: 'audio/mpeg',
  mpeg: 'audio/mpeg',
  mp4: 'video/mp4',
  m4a: 'video/mp4',
  m4p: 'video/mp4',
  ogv: 'video/ogg',
  ogg: 'video/ogg',
  mov: 'video/quicktime',
  webm: 'video/webm'
};

function Video(_ref) {
  var autoAnimateId = _ref.autoAnimateId,
      autoplay = _ref.autoplay,
      controls = _ref.controls,
      fragmentIndex = _ref.fragmentIndex,
      height = _ref.height,
      lazy = _ref.lazy,
      loop = _ref.loop,
      muted = _ref.muted,
      preload = _ref.preload,
      width = _ref.width,
      src = _ref.src,
      props = _objectWithoutProperties(_ref, ["autoAnimateId", "autoplay", "controls", "fragmentIndex", "height", "lazy", "loop", "muted", "preload", "width", "src"]);

  if (Array.isArray(src)) {
    return /*#__PURE__*/React.createElement("video", _extends({}, getClassNameProps(props), {
      "data-id": autoAnimateId,
      "data-autoplay": autoplay,
      controls: controls,
      muted: muted,
      loop: loop,
      height: height,
      width: width,
      "data-fragment-index": fragmentIndex
    }), src.map(function (element) {
      var _$exec;

      return /*#__PURE__*/React.createElement("source", {
        src: lazy ? '' : element,
        "data-src": lazy ? element : false,
        "data-preload": preload,
        type: formatMap$1[((_$exec = /\.[^.]+$/.exec(element)) === null || _$exec === void 0 ? void 0 : _$exec[0]) || 'mp4']
      });
    }));
  }

  return /*#__PURE__*/React.createElement("video", _extends({}, getClassNameProps(props), {
    "data-autoplay": autoplay,
    src: lazy ? '' : src,
    "data-src": lazy ? src : false,
    "data-preload": preload,
    controls: controls,
    muted: muted,
    loop: loop,
    height: height,
    width: width,
    "data-fragment-index": fragmentIndex
  }));
}

var css_248z$1 = "code[class*='language-'],\npre[class*='language-'] {\n  /* use the reveal value, not the prism value */\n  font-size: 0.55em !important;\n}\n\n.reveal pre[class*='language-'].line-numbers,\n.reveal pre[class*='lang-'].line-numbers {\n  padding-left: 1em !important;\n}\n\n.reveal pre[class*='language-'].line-numbers > code,\n.reveal pre[class*='lang-'].line-numbers > code {\n  padding-left: 3.8em !important;\n}\n\n.reveal pre[data-auto-animate-target] {\n  overflow: auto !important;\n}\n\n.reveal pre code {\n  overflow: visible !important;\n}\n\n.reveal .line-numbers-rows {\n  top: 5px !important;\n  left: 0 !important;\n}\n";
styleInject(css_248z$1);

function startup(Prism) {
  if (typeof self === 'undefined' || !self.Prism || !self.document) {
    return;
  }
  /**
   * Plugin name which is used as a class name for <pre> which is activating the plugin
   * @type {String}
   */


  var PLUGIN_NAME = 'line-numbers';
  /**
   * Regular expression used for determining line breaks
   * @type {RegExp}
   */

  var NEW_LINE_EXP = /\n(?!$)/g;
  /**
   * Global exports
   */

  var config = Prism.plugins.lineNumbers = {
    /**
     * Get node for provided line number
     * @param {Element} element pre element
     * @param {Number} number line number
     * @return {Element|undefined}
     */
    getLine: function getLine(element, number) {
      if (element.tagName !== 'PRE' || !element.classList.contains(PLUGIN_NAME)) {
        return;
      }

      var lineNumberRows = element.querySelector('.line-numbers-rows');

      if (!lineNumberRows) {
        return;
      }

      var lineNumberStart = parseInt(element.getAttribute('data-start') || '', 10) || 1;
      var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);

      if (number < lineNumberStart) {
        number = lineNumberStart;
      }

      if (number > lineNumberEnd) {
        number = lineNumberEnd;
      }

      var lineIndex = number - lineNumberStart;
      return lineNumberRows.children[lineIndex];
    },

    /**
     * Resizes the line numbers of the given element.
     *
     * This function will not add line numbers. It will only resize existing ones.
     * @param {HTMLElement} element A `<pre>` element with line numbers.
     * @returns {void}
     */
    resize: function resize(element) {
      resizeElements([element]);
    },

    /**
     * Whether the plugin can assume that the units font sizes and margins are not depended on the size of
     * the current viewport.
     *
     * Setting this to `true` will allow the plugin to do certain optimizations for better performance.
     *
     * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.
     *
     * @type {boolean}
     */
    assumeViewportIndependence: true
  };
  /**
   * Resizes the given elements.
   *
   * @param {HTMLElement[]} elements
   */

  function resizeElements(elements) {
    elements = elements.filter(function (e) {
      var codeStyles = getStyles(e);
      var whiteSpace = codeStyles === null || codeStyles === void 0 ? void 0 : codeStyles.whiteSpace;
      return whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line';
    });

    if (elements.length == 0) {
      return;
    }

    var infos = elements.map(function (element) {
      var _codeElement$textCont;

      var codeElement = element.querySelector('code');
      var lineNumbersWrapper = element.querySelector('.line-numbers-rows');

      if (!codeElement || !lineNumbersWrapper) {
        return undefined;
      }
      /** @type {HTMLElement} */


      var lineNumberSizer = element.querySelector('.line-numbers-sizer');
      var codeLines = (_codeElement$textCont = codeElement.textContent) === null || _codeElement$textCont === void 0 ? void 0 : _codeElement$textCont.split(NEW_LINE_EXP);

      if (!lineNumberSizer) {
        lineNumberSizer = document.createElement('span');
        lineNumberSizer.className = 'line-numbers-sizer';
        codeElement.appendChild(lineNumberSizer);
      }

      lineNumberSizer.innerHTML = '0';
      lineNumberSizer.style.display = 'block';
      var oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;
      lineNumberSizer.innerHTML = '';
      return {
        element: element,
        lines: codeLines,
        lineHeights: [],
        oneLinerHeight: oneLinerHeight,
        sizer: lineNumberSizer
      };
    }).filter(function (a) {
      return !!a;
    });
    infos.forEach(function (info) {
      if (!info) {
        return;
      }

      var lineNumberSizer = info.sizer;
      var _info$lines = info.lines,
          lines = _info$lines === void 0 ? [] : _info$lines;
      var lineHeights = info.lineHeights;
      var oneLinerHeight = info.oneLinerHeight;
      lineHeights[lines.length - 1] = undefined;
      lines.forEach(function (line, index) {
        if (line && line.length > 1) {
          var e = lineNumberSizer.appendChild(document.createElement('span'));
          e.style.display = 'block';
          e.textContent = line;
        } else {
          lineHeights[index] = oneLinerHeight;
        }
      });
    });
    infos.forEach(function (info) {
      var lineNumberSizer = info.sizer;
      var lineHeights = info.lineHeights;
      var childIndex = 0;

      for (var i = 0; i < lineHeights.length; i++) {
        if (lineHeights[i] === undefined) {
          lineHeights[i] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;
        }
      }
    });
    infos.forEach(function (info) {
      var lineNumberSizer = info.sizer;
      var wrapper = info.element.querySelector('.line-numbers-rows');
      lineNumberSizer.style.display = 'none';
      lineNumberSizer.innerHTML = '';
      info.lineHeights.forEach(function (height, lineNumber) {
        if (!wrapper) {
          return;
        }

        wrapper.children[lineNumber].style.height = "".concat(height, "px");
      });
    });
  }
  /**
   * Returns style declarations for the element
   * @param {Element} element
   */


  var getStyles = function getStyles(element) {
    var _window$getComputedSt, _window;

    if (!element) {
      return null;
    }

    return ((_window$getComputedSt = (_window = window).getComputedStyle) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.call(_window, element)) || element.currentStyle || null;
  };

  var lastWidth;
  window.addEventListener('resize', function () {
    if (config.assumeViewportIndependence && lastWidth === window.innerWidth) {
      return;
    }

    lastWidth = window.innerWidth;
    resizeElements(Array.prototype.slice.call(document.querySelectorAll("pre.".concat(PLUGIN_NAME))));
  });
  Prism.hooks.add('complete', function (env) {
    if (!env.code) {
      return;
    }

    var code =
    /** @type {Element} */
    env.element;
    var pre =
    /** @type {HTMLElement} */
    code.parentNode; // works only for <code> wrapped inside <pre> (not inline)

    if (!pre || !/pre/i.test(pre.nodeName)) {
      return;
    } // Abort if line numbers already exists


    if (code.querySelector('.line-numbers-rows')) {
      return;
    } // only add line numbers if <code> or one of its ancestors has the `line-numbers` class


    if (!Prism.util.isActive(code, PLUGIN_NAME)) {
      return;
    } // Remove the class 'line-numbers' from the <code>


    code.classList.remove(PLUGIN_NAME); // Add the class 'line-numbers' to the <pre>

    pre.classList.add(PLUGIN_NAME);
    var match = env.code.match(NEW_LINE_EXP);
    var linesNum = match ? match.length + 1 : 1;
    var lineNumbersWrapper;
    var lines = new Array(linesNum + 1).join('<span></span>');
    lineNumbersWrapper = document.createElement('span');
    lineNumbersWrapper.setAttribute('aria-hidden', 'true');
    lineNumbersWrapper.className = 'line-numbers-rows';
    lineNumbersWrapper.innerHTML = lines;

    if (pre.hasAttribute('data-start')) {
      pre.style.counterReset = "linenumber ".concat(parseInt(pre.getAttribute('data-start') || '', 10) - 1);
    }

    env.element.appendChild(lineNumbersWrapper); // this breaks line numbers on smaller screen sizes, and in the speaker view
    // resizeElements([pre]);

    Prism.hooks.run('line-numbers', env);
  });
  Prism.hooks.add('line-numbers', function (env) {
    env.plugins = env.plugins || {};
    env.plugins.lineNumbers = true;
  });
}

window.Prism = Prism;
function enablePrismLineNumbers() {
  startup(Prism);
}
function addCustomPrismLanguage(languageDef) {
  languageDef(Prism);
}

/**
 * Given the current slide, get all of the <Code> sections, and
 * for each, scroll to the top-most highlighted line smoothly
 */
function scrollToTopmostHighlightedLine(currentSlide) {
  var codeSections = currentSlide.querySelectorAll('pre[class*="language-"], pre[class*="lang-"]');

  var _iterator = _createForOfIteratorHelper(codeSections),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _highlight$parentElem, _highlight$parentElem2;

      var code = _step.value;
      var highlight = code.querySelector('.line-highlight');

      if (!highlight || !highlight.parentElement) {
        return;
      }

      highlight.parentElement.scrollTo({
        top: highlight.offsetTop - ((highlight === null || highlight === void 0 ? void 0 : (_highlight$parentElem = highlight.parentElement) === null || _highlight$parentElem === void 0 ? void 0 : (_highlight$parentElem2 = _highlight$parentElem.parentElement) === null || _highlight$parentElem2 === void 0 ? void 0 : _highlight$parentElem2.scrollTop) || 0) - 30,
        behavior: 'smooth'
      });
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
/*!
 * reveal.js plugin that adds syntax highlight support using Prism.js.
 */


var PrismHighlightPlugin = {
  id: 'prism-highlight',
  highlightedSlides: new WeakMap(),

  /**
   * Highlights code blocks withing the given deck.
   *
   * Note that this can be called multiple times if
   * there are multiple presentations on one page.
   */
  init: function init(reveal) {
    reveal.on('ready', function () {
      var currentSlide = reveal.getCurrentSlide();
      PrismHighlightPlugin.highlightedSlides.set(currentSlide, true);
      Prism.highlightAllUnder(currentSlide); // scroll to top-most highlighted line

      scrollToTopmostHighlightedLine(currentSlide);
    });
    reveal.on('slidechanged', function (_ref) {
      var currentSlide = _ref.currentSlide;

      // highlight the slides just-in-time
      if (PrismHighlightPlugin.highlightedSlides.has(currentSlide)) {
        // don't highlight slides multiple times
        return;
      }

      PrismHighlightPlugin.highlightedSlides.set(currentSlide, true);
      Prism.highlightAllUnder(currentSlide);
    });
    reveal.on('slidetransitionend', function () {
      var currentSlide = reveal.getCurrentSlide(); // scroll to top-most highlighted line

      scrollToTopmostHighlightedLine(currentSlide);
    });
  }
};
var PrismHighlightPlugin$1 = (function () {
  return PrismHighlightPlugin;
});

/*!
 * revealjs-react 1.0.0
 * MIT licensed
 *
 * Copyright (C) 2020 Blake Nedved, https://blakeanedved.github.io/
 */
var HighlightPlugin = HighlightPlugin$1;
var MathPlugin = MathPlugin$1;
var MarkdownPlugin = MarkdownPlugin$1;
var NotesPlugin = NotesPlugin$1;
var SearchPlugin = SearchPlugin$1;
var ZoomPlugin = ZoomPlugin$1;

export { Audio, BlockQuote, Code, Div, Example, FigCaption, Figure, Footer, Fragment, H1, H2, H3, H4, H5, H6, Header, HighlightPlugin, IFrame, Image, Li, Link, Main, MarkdownPlugin, MathPlugin, Note, NotesPlugin, Ol, P, PrismHighlightPlugin$1 as PrismHighlightPlugin, RevealContext, RevealJS, SearchPlugin, Slide, Span, Ul, Video, ZoomPlugin, addCustomPrismLanguage, enablePrismLineNumbers, useReveal };
//# sourceMappingURL=index.esm.js.map
